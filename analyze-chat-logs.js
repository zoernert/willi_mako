#!/usr/bin/env node
/**
 * Willi-Mako Chat Test Log Analyzer
 * 
 * This script analyzes the debug logs generated by the willi-mako-chat-test.js script
 * and provides insights on system performance and response quality.
 */

const fs = require('fs');
const path = require('path');

// ANSI color codes
const RED = '\x1b[31m';
const GREEN = '\x1b[32m';
const YELLOW = '\x1b[33m';
const BLUE = '\x1b[34m';
const RESET = '\x1b[0m';

// Configuration
const LOG_DIR = path.join(__dirname, 'logs');

// Check if logs directory exists
if (!fs.existsSync(LOG_DIR)) {
  console.error(`${RED}Error: Logs directory not found.${RESET}`);
  console.error('Please run the chat test script first: ./willi-mako-chat-test.js');
  process.exit(1);
}

// Get all log files
const logFiles = fs.readdirSync(LOG_DIR)
  .filter(file => file.endsWith('.log.json'))
  .map(file => path.join(LOG_DIR, file))
  .sort((a, b) => fs.statSync(b).mtime.getTime() - fs.statSync(a).mtime.getTime()); // Sort by modification time (newest first)

if (logFiles.length === 0) {
  console.error(`${RED}Error: No log files found.${RESET}`);
  console.error('Please run the chat test script first: ./willi-mako-chat-test.js');
  process.exit(1);
}

// Ask user which log file to analyze
if (process.argv.includes('--latest')) {
  // Analyze the latest log file
  analyzeLogFile(logFiles[0]);
} else if (process.argv.includes('--all')) {
  // Analyze all log files
  console.log(`${YELLOW}Analyzing all ${logFiles.length} log files...\n${RESET}`);
  
  const allResults = [];
  
  for (const logFile of logFiles) {
    const result = analyzeLogFile(logFile, false);
    allResults.push(result);
  }
  
  console.log(`${YELLOW}\nSummary of all log files:${RESET}`);
  
  // Combine all results
  const totalQueries = allResults.reduce((sum, result) => sum + result.totalQueries, 0);
  const totalAvgResponseTime = allResults.reduce((sum, result) => sum + result.avgResponseTime * result.totalQueries, 0) / totalQueries;
  const totalAvgSourceCount = allResults.reduce((sum, result) => sum + result.avgSourceCount * result.totalQueries, 0) / totalQueries;
  const totalAvgVectorScore = allResults.reduce((sum, result) => sum + result.avgVectorScore * result.totalQueries, 0) / totalQueries;
  const totalEnhancedQueryCount = allResults.reduce((sum, result) => sum + result.enhancedQueryCount, 0);
  
  console.log(`${GREEN}Total queries: ${totalQueries}${RESET}`);
  console.log(`${GREEN}Average response time: ${totalAvgResponseTime.toFixed(2)}ms${RESET}`);
  console.log(`${GREEN}Average source count: ${totalAvgSourceCount.toFixed(2)}${RESET}`);
  console.log(`${GREEN}Average vector search score: ${totalAvgVectorScore.toFixed(4)}${RESET}`);
  console.log(`${GREEN}Enhanced queries: ${totalEnhancedQueryCount} (${((totalEnhancedQueryCount / totalQueries) * 100).toFixed(2)}%)${RESET}`);
} else {
  // Print all available log files and let the user choose
  console.log(`${YELLOW}Available log files:${RESET}`);
  
  logFiles.forEach((file, index) => {
    const stats = fs.statSync(file);
    console.log(`${index + 1}. ${path.basename(file)} (${new Date(stats.mtime).toLocaleString()})`);
  });
  
  console.log('\nUsage:');
  console.log('  node analyze-chat-logs.js --latest  # Analyze the latest log file');
  console.log('  node analyze-chat-logs.js --all     # Analyze all log files');
  console.log('  node analyze-chat-logs.js <number>  # Analyze a specific log file');
  
  const logIndex = parseInt(process.argv[2], 10);
  
  if (!isNaN(logIndex) && logIndex > 0 && logIndex <= logFiles.length) {
    analyzeLogFile(logFiles[logIndex - 1]);
  } else if (process.argv.length > 2) {
    console.error(`${RED}Error: Invalid log file index.${RESET}`);
    process.exit(1);
  } else {
    // Default to analyzing the latest log file
    analyzeLogFile(logFiles[0]);
  }
}

/**
 * Analyze a log file and print the results
 */
function analyzeLogFile(logFile, printDetails = true) {
  const logData = JSON.parse(fs.readFileSync(logFile, 'utf8'));
  
  if (printDetails) {
    console.log(`${YELLOW}\nAnalyzing log file: ${path.basename(logFile)}${RESET}`);
    console.log(`${YELLOW}Timestamp: ${new Date(logData[0]?.timestamp).toLocaleString()}${RESET}`);
    console.log(`${YELLOW}Total entries: ${logData.length}${RESET}`);
  }
  
  // Find all chat responses
  const chatResponses = logData.filter(entry => 
    entry.type === 'success' && 
    entry.message === 'Chat response received' &&
    entry.data?.metrics
  );
  
  // Calculate metrics
  const responseTimes = chatResponses.map(entry => entry.data.metrics.responseTime);
  const sourceCounts = chatResponses.map(entry => entry.data.metrics.sourceCount);
  const vectorScores = chatResponses
    .filter(entry => entry.data.metrics.vectorSearchScore !== null)
    .map(entry => entry.data.metrics.vectorSearchScore);
  
  const enhancedQueries = chatResponses.filter(entry => entry.data.metrics.hasEnhancedQuery);
  const cs30Responses = chatResponses.filter(entry => entry.data.metrics.hasCs30Response);
  
  // Calculate averages
  const avgResponseTime = responseTimes.length > 0 ? 
    responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length : 0;
  const avgSourceCount = sourceCounts.length > 0 ? 
    sourceCounts.reduce((sum, count) => sum + count, 0) / sourceCounts.length : 0;
  const avgVectorScore = vectorScores.length > 0 ? 
    vectorScores.reduce((sum, score) => sum + score, 0) / vectorScores.length : 0;
  
  // Create result object
  const result = {
    totalQueries: chatResponses.length,
    avgResponseTime,
    avgSourceCount,
    avgVectorScore,
    enhancedQueryCount: enhancedQueries.length,
    cs30ResponseCount: cs30Responses.length
  };
  
  if (printDetails) {
    console.log(`${GREEN}\nTotal queries: ${chatResponses.length}${RESET}`);
    
    if (chatResponses.length === 0) {
      console.log(`${RED}No successful chat responses found in the log.${RESET}`);
      console.log(`${RED}Check for API connection issues or errors in the log.${RESET}`);
    } else {
      console.log(`${GREEN}Average response time: ${avgResponseTime.toFixed(2)}ms${RESET}`);
      console.log(`${GREEN}Average source count: ${avgSourceCount.toFixed(2)}${RESET}`);
      console.log(`${GREEN}Average vector search score: ${avgVectorScore.toFixed(4)}${RESET}`);
      console.log(`${GREEN}Enhanced queries: ${enhancedQueries.length} (${((enhancedQueries.length / chatResponses.length) * 100).toFixed(2)}%)${RESET}`);
      console.log(`${GREEN}CS30 responses: ${cs30Responses.length} (${((cs30Responses.length / chatResponses.length) * 100).toFixed(2)}%)${RESET}`);
      
      // Print individual query analysis
      console.log(`${YELLOW}\nIndividual query analysis:${RESET}`);
      
      chatResponses.forEach((entry, index) => {
        const { query, metrics } = entry.data;
        
        console.log(`${BLUE}\nQuery ${index + 1}: ${query}${RESET}`);
        console.log(`Response time: ${metrics.responseTime}ms`);
        console.log(`Source count: ${metrics.sourceCount}`);
        console.log(`Vector search score: ${metrics.vectorSearchScore || 'N/A'}`);
        console.log(`Enhanced query: ${metrics.hasEnhancedQuery ? 'Yes' : 'No'}`);
        console.log(`CS30 response: ${metrics.hasCs30Response ? 'Yes' : 'No'}`);
        
        // Highlight potential issues
        if (metrics.responseTime > avgResponseTime * 1.5) {
          console.log(`${RED}⚠ Slow response time${RESET}`);
        }
        
        if (metrics.sourceCount === 0) {
          console.log(`${RED}⚠ No sources found${RESET}`);
        }
        
        if (metrics.vectorSearchScore && metrics.vectorSearchScore < 0.6) {
          console.log(`${RED}⚠ Low vector search score${RESET}`);
        }
      });
    }
    
    // Improvement suggestions
    console.log(`${YELLOW}\nImprovement suggestions:${RESET}`);
    
    // Check for API connection issues
    const failedRequests = logData.filter(entry => entry.type === 'error' && entry.message.includes('Chat query failed'));
    if (failedRequests.length > 0) {
      console.log(`${RED}• API connection issues detected: ${failedRequests.length} failed requests.${RESET}`);
      const firstError = failedRequests[0].data?.message || 'Unknown error';
      console.log(`${RED}  First error: ${firstError}${RESET}`);
      console.log(`${RED}  Check API endpoint configuration and server status.${RESET}`);
    }
    
    if (chatResponses.length > 0) {
      if (avgResponseTime > 2000) {
        console.log(`${RED}• Response times are high (> 2000ms). Consider optimizing API performance.${RESET}`);
      }
      
      if (avgSourceCount < 2) {
        console.log(`${RED}• Average source count is low. Consider improving vector search relevance.${RESET}`);
      }
      
      if (avgVectorScore < 0.7) {
        console.log(`${RED}• Average vector search score is low. Consider tuning embedding models or enhancing the knowledge base.${RESET}`);
      }
      
      const noSourceQueries = chatResponses.filter(entry => entry.data.metrics.sourceCount === 0);
      if (noSourceQueries.length > 0) {
        console.log(`${RED}• ${noSourceQueries.length} queries found no sources. These queries may need additional knowledge base entries:${RESET}`);
        
        noSourceQueries.forEach(entry => {
          console.log(`  - "${entry.data.query}"`);
        });
      }
    }
  }
  
  return result;
}
