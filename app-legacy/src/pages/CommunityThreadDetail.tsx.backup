import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import ReactMarkdown from 'react-markdown';
import {
  Box,
  Typography,
  Card,
  CardContent,
  Button,
  Chip,
  TextField,
  CircularProgress,
  Alert,
  Divider,
  Paper,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Fab,
  Tabs,
  Tab,
} from '@mui/material';
import { Grid } from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Save as SaveIcon,
  Cancel as CancelIcon,
  Comment as CommentIcon,
  CheckCircle as CheckIcon,
  Schedule as ScheduleIcon,
  RateReview as ReviewIcon,
  Forum as ForumIcon,
  ArrowBack as ArrowBackIcon,
  RocketLaunch as InitiativeIcon,
} from '@mui/icons-material';
import { useAuth } from '../contexts/AuthContext';
import { useSnackbar } f        )}exts/SnackbarContext';
import { InitiativeView } from '../components/Community/InitiativeView';
import { communityService } from '../services/communityService';
import { CommunityInitiative } from '../types/community';

interface CommunityThread {
  id: string;
  title: string;
  status: 'discussing' | 'review' | 'final';
  tags: string[];
  created_by_user_id: string;
  created_at: string;
  updated_at: string;
  document_content: {
    problem_description?: string;
    context?: string;
    analysis?: string;
    solution_proposals?: Array<{
      id: string;
      content: string;
      created_by: string;
      created_at: string;
    }>;
    final_solution?: {
      content: string;
      approved_by?: string;
      approved_at?: string;
    };
  };
}

interface Comment {
  id: string;
  thread_id: string;
  block_id: string;
  content: string;
  created_by_user_id: string;
  created_at: string;
}

const CommunityThreadDetail: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { state } = useAuth();
  const { showSnackbar } = useSnackbar();
  
  const [thread, setThread] = useState<CommunityThread | null>(null);
  const [loading, setLoading] = useState(true);
  const [editingSection, setEditingSection] = useState<string | null>(null);
  const [sectionContent, setSectionContent] = useState('');
  const [newProposal, setNewProposal] = useState('');
  const [showProposalDialog, setShowProposalDialog] = useState(false);
  const [comments, setComments] = useState<Comment[]>([]);
  const [threadInitiative, setThreadInitiative] = useState<CommunityInitiative | null>(null);
  const [loadingInitiative, setLoadingInitiative] = useState(false);
  const [showCreateInitiativeDialog, setShowCreateInitiativeDialog] = useState(false);
  const [newInitiativeTitle, setNewInitiativeTitle] = useState('');
  const [newInitiativeAudience, setNewInitiativeAudience] = useState('');
  
  // Markdown editor state
  const [editMode, setEditMode] = useState<'write' | 'preview'>('write');

  useEffect(() => {
    console.log('Effect triggered - ID:', id, 'Token:', !!state.token);
    if (id && state.token) {
      fetchThread();
      fetchComments();
      fetchThreadInitiative();
      fetchThreadInitiative();
    } else if (id && !state.token) {
      console.log('No token available, waiting...');
      // Wait a bit for token to be loaded from localStorage
      const timer = setTimeout(() => {
        if (state.token) {
          fetchThread();
          fetchComments();
          fetchThreadInitiative();
        } else {
          console.error('No token available after timeout');
          navigate('/login');
        }
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [id, state.token]);

  const fetchThread = async () => {
    try {
      console.log('Fetching thread with ID:', id);
      console.log('Token available:', !!state.token);
      
      const response = await fetch(`/api/community/threads/${id}`, {
        headers: {
          Authorization: `Bearer ${state.token}`,
        },
      });
      
      console.log('Response status:', response.status);
      
      if (response.ok) {
        const data = await response.json();
        console.log('Thread data received:', data);
        setThread(data.data);
      } else {
        const errorText = await response.text();
        console.error('Error response:', response.status, errorText);
        showSnackbar('Fehler beim Laden des Threads', 'error');
        navigate('/community');
      }
    } catch (error) {
      showSnackbar('Netzwerkfehler beim Laden des Threads', 'error');
      navigate('/community');
    } finally {
      setLoading(false);
    }
  };

  const fetchComments = async () => {
    try {
      const response = await fetch(`/api/community/threads/${id}/comments`, {
        headers: {
          Authorization: `Bearer ${state.token}`,
        },
      });
      
      if (response.ok) {
        const data = await response.json();
        setComments(data.data || []);
      }
    } catch (error) {
      console.error('Error fetching comments:', error);
    }
  };

  const fetchThreadInitiative = async () => {
    if (!id) return;
    
    try {
      const response = await communityService.initiative.getThreadInitiatives(id);
      if (response.success && response.data) {
        setThreadInitiative(response.data);
      }
    } catch (error) {
      // No initiative exists yet - this is expected for many threads
      console.log('No initiative found for thread (this is normal)');
    }
  };

  const handleUpdateSection = async (sectionKey: string, content: string) => {
    try {
      const patchOps = [
        {
          op: 'replace',
          path: `/${sectionKey}`,
          value: content,
        },
      ];

      const response = await fetch(`/api/community/threads/${id}/document`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${state.token}`,
          'If-Version': thread?.updated_at || '',
        },
        body: JSON.stringify(patchOps),
      });

      if (response.ok) {
        const data = await response.json();
        setThread(data.data);
        setEditingSection(null);
        setSectionContent('');
        showSnackbar('Sektion erfolgreich aktualisiert', 'success');
      } else if (response.status === 409) {
        showSnackbar('Konflikt: Thread wurde von jemand anderem bearbeitet. Bitte laden Sie die Seite neu.', 'warning');
        fetchThread();
      } else {
        showSnackbar('Fehler beim Aktualisieren der Sektion', 'error');
      }
    } catch (error) {
      showSnackbar('Netzwerkfehler beim Aktualisieren', 'error');
    }
  };

  const handleAddProposal = async () => {
    try {
      const patchOps = [
        {
          op: 'add',
          path: '/solution_proposals/-',
          value: {
            content: newProposal,
          },
        },
      ];

      const response = await fetch(`/api/community/threads/${id}/document`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${state.token}`,
          'If-Version': thread?.updated_at || '',
        },
        body: JSON.stringify(patchOps),
      });

      if (response.ok) {
        const data = await response.json();
        setThread(data.data);
        setNewProposal('');
        setShowProposalDialog(false);
        showSnackbar('Lösungsvorschlag hinzugefügt', 'success');
      } else if (response.status === 409) {
        showSnackbar('Konflikt: Thread wurde von jemand anderem bearbeitet. Bitte laden Sie die Seite neu.', 'warning');
        fetchThread();
      } else {
        showSnackbar('Fehler beim Hinzufügen des Vorschlags', 'error');
      }
    } catch (error) {
      showSnackbar('Netzwerkfehler beim Hinzufügen des Vorschlags', 'error');
    }
  };

  const startEditing = (section: string, currentContent: string) => {
    setEditingSection(section);
    setSectionContent(currentContent || '');
  };

  const cancelEditing = () => {
    setEditingSection(null);
    setSectionContent('');
  };

  const handleCreateInitiative = async () => {
    if (!id || !newInitiativeTitle.trim()) return;

    setLoadingInitiative(true);
    try {
      const response = await communityService.initiative.createInitiative(id, {
        title: newInitiativeTitle.trim(),
        target_audience: newInitiativeAudience || undefined
      });

      if (response.success && response.data) {
        setThreadInitiative(response.data);
        setShowCreateInitiativeDialog(false);
        setNewInitiativeTitle('');
        setNewInitiativeAudience('');
        showSnackbar('Initiative erfolgreich erstellt!');
      }
    } catch (error) {
      console.error('Error creating initiative:', error);
      showSnackbar('Fehler beim Erstellen der Initiative', 'error');
    } finally {
      setLoadingInitiative(false);
    }
  };

  const handleUpdateInitiative = async (updatedInitiative: CommunityInitiative) => {
    try {
      const response = await communityService.initiative.updateInitiative(
        updatedInitiative.id,
        {
          title: updatedInitiative.title,
          target_audience: updatedInitiative.target_audience,
          draft_content: updatedInitiative.draft_content
        }
      );

      if (response.success && response.data) {
        setThreadInitiative(response.data);
        showSnackbar('Initiative erfolgreich aktualisiert');
      }
    } catch (error) {
      console.error('Error updating initiative:', error);
      throw error; // Re-throw so InitiativeView can handle it
    }
  };

  const handleInitiativeStatusChange = async (
    initiativeId: string, 
    status: 'draft' | 'refining' | 'submitted',
    submissionDetails?: any
  ) => {
    try {
      const response = await communityService.initiative.updateStatus(initiativeId, {
        status,
        submission_details: submissionDetails
      });

      if (response.success) {
        // Refresh initiative data
        await fetchThreadInitiative();
        showSnackbar(`Initiative-Status geändert zu: ${status}`);
      }
    } catch (error) {
      console.error('Error updating initiative status:', error);
      throw error; // Re-throw so InitiativeView can handle it
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'discussing': return 'primary';
      case 'review': return 'warning';
      case 'final': return 'success';
      default: return 'default';
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'discussing': return <ForumIcon />;
      case 'review': return <ReviewIcon />;
      case 'final': return <CheckIcon />;
      default: return <ScheduleIcon />;
    }
  };

  const getStatusText = (status: string) => {
    switch (status) {
      case 'discussing': return 'Diskussion';
      case 'review': return 'Review';
      case 'final': return 'Finalisiert';
      default: return status;
    }
  };

  // Markdown Editor Component
  const MarkdownEditor: React.FC<{
    value: string;
    onChange: (value: string) => void;
    placeholder?: string;
    rows?: number;
  }> = ({ value, onChange, placeholder, rows = 4 }) => {
    return (
      <Box>
        <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}>
          <Tabs value={editMode} onChange={(_, newValue) => setEditMode(newValue)}>
            <Tab label="Schreiben" value="write" />
            <Tab label="Vorschau" value="preview" />
          </Tabs>
        </Box>
        
        {editMode === 'write' ? (
          <TextField
            fullWidth
            multiline
            rows={rows}
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            helperText="Markdown-Formatierung wird unterstützt (z.B. **fett**, *kursiv*, # Überschrift, - Listen)"
            sx={{ mb: 2 }}
          />
        ) : (
          <Box
            sx={{
              minHeight: `${rows * 24}px`,
              p: 2,
              border: 1,
              borderColor: 'divider',
              borderRadius: 1,
              mb: 2,
              backgroundColor: 'grey.50'
            }}
          >
            {value ? (
              <ReactMarkdown
                components={{
                  p: ({ children }) => (
                    <Typography variant="body1" sx={{ mb: 1 }}>
                      {children}
                    </Typography>
                  ),
                  h1: ({ children }) => (
                    <Typography variant="h4" sx={{ mb: 1, fontWeight: 'bold' }}>
                      {children}
                    </Typography>
                  ),
                  h2: ({ children }) => (
                    <Typography variant="h5" sx={{ mb: 1, fontWeight: 'bold' }}>
                      {children}
                    </Typography>
                  ),
                  h3: ({ children }) => (
                    <Typography variant="h6" sx={{ mb: 1, fontWeight: 'bold' }}>
                      {children}
                    </Typography>
                  ),
                  ul: ({ children }) => (
                    <Box component="ul" sx={{ mb: 1, pl: 2 }}>
                      {children}
                    </Box>
                  ),
                  ol: ({ children }) => (
                    <Box component="ol" sx={{ mb: 1, pl: 2 }}>
                      {children}
                    </Box>
                  ),
                  li: ({ children }) => (
                    <Typography component="li" variant="body1" sx={{ mb: 0.5 }}>
                      {children}
                    </Typography>
                  ),
                  strong: ({ children }) => (
                    <Typography component="strong" sx={{ fontWeight: 'bold' }}>
                      {children}
                    </Typography>
                  ),
                  em: ({ children }) => (
                    <Typography component="em" sx={{ fontStyle: 'italic' }}>
                      {children}
                    </Typography>
                  ),
                  code: ({ children }) => (
                    <Typography
                      component="code"
                      sx={{
                        backgroundColor: 'rgba(0,0,0,0.1)',
                        padding: '2px 4px',
                        borderRadius: '4px',
                        fontFamily: 'monospace',
                        fontSize: '0.9em',
                      }}
                    >
                      {children}
                    </Typography>
                  ),
                  blockquote: ({ children }) => (
                    <Paper
                      sx={{
                        p: 1,
                        borderLeft: '4px solid',
                        borderLeftColor: 'primary.main',
                        backgroundColor: 'rgba(0,0,0,0.05)',
                        mb: 1,
                      }}
                    >
                      {children}
                    </Paper>
                  ),
                }}
              >
                {value}
              </ReactMarkdown>
            ) : (
              <Typography color="text.secondary" sx={{ fontStyle: 'italic' }}>
                Vorschau wird hier angezeigt...
              </Typography>
            )}
          </Box>
        )}
      </Box>
    );
  };

  // Markdown Renderer Component
  const MarkdownRenderer: React.FC<{ content?: string; fallback?: string }> = ({ 
    content, 
    fallback = 'Noch kein Inhalt vorhanden.' 
  }) => {
    if (!content) {
      return (
        <Typography variant="body1" color="text.secondary" sx={{ fontStyle: 'italic' }}>
          {fallback}
        </Typography>
      );
    }

    return (
      <ReactMarkdown
        components={{
          p: ({ children }) => (
            <Typography variant="body1" sx={{ mb: 1 }}>
              {children}
            </Typography>
          ),
          h1: ({ children }) => (
            <Typography variant="h4" sx={{ mb: 1, fontWeight: 'bold' }}>
              {children}
            </Typography>
          ),
          h2: ({ children }) => (
            <Typography variant="h5" sx={{ mb: 1, fontWeight: 'bold' }}>
              {children}
            </Typography>
          ),
          h3: ({ children }) => (
            <Typography variant="h6" sx={{ mb: 1, fontWeight: 'bold' }}>
              {children}
            </Typography>
          ),
          ul: ({ children }) => (
            <Box component="ul" sx={{ mb: 1, pl: 2 }}>
              {children}
            </Box>
          ),
          ol: ({ children }) => (
            <Box component="ol" sx={{ mb: 1, pl: 2 }}>
              {children}
            </Box>
          ),
          li: ({ children }) => (
            <Typography component="li" variant="body1" sx={{ mb: 0.5 }}>
              {children}
            </Typography>
          ),
          strong: ({ children }) => (
            <Typography component="strong" sx={{ fontWeight: 'bold' }}>
              {children}
            </Typography>
          ),
          em: ({ children }) => (
            <Typography component="em" sx={{ fontStyle: 'italic' }}>
              {children}
            </Typography>
          ),
          code: ({ children }) => (
            <Typography
              component="code"
              sx={{
                backgroundColor: 'rgba(0,0,0,0.1)',
                padding: '2px 4px',
                borderRadius: '4px',
                fontFamily: 'monospace',
                fontSize: '0.9em',
              }}
            >
              {children}
            </Typography>
          ),
          blockquote: ({ children }) => (
            <Paper
              sx={{
                p: 1,
                borderLeft: '4px solid',
                borderLeftColor: 'primary.main',
                backgroundColor: 'rgba(0,0,0,0.05)',
                mb: 1,
              }}
            >
              {children}
            </Paper>
          ),
        }}
      >
        {content}
      </ReactMarkdown>
    );
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
        <CircularProgress />
      </Box>
    );
  }

  if (!thread) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="error">Thread nicht gefunden</Alert>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3 }} data-context="community">
      {/* Header */}
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
        <IconButton onClick={() => navigate('/community')} sx={{ mr: 2 }}>
          <ArrowBackIcon />
        </IconButton>
        <Box sx={{ flexGrow: 1 }}>
          <Typography variant="h4" component="h1" sx={{ color: 'var(--color-primary, #ee7f4b)' }}>
            {thread.title}
          </Typography>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 1 }}>
            <Chip
              icon={getStatusIcon(thread.status)}
              label={getStatusText(thread.status)}
              color={getStatusColor(thread.status) as any}
            />
            <Typography variant="body2" color="text.secondary">
              Erstellt am {new Date(thread.created_at).toLocaleDateString('de-DE')}
            </Typography>
          </Box>
        </Box>
      </Box>

      {/* Tags */}
      {thread.tags.length > 0 && (
        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 3 }}>
          {thread.tags.map((tag) => (
            <Chip key={tag} label={tag} variant="outlined" />
          ))}
        </Box>
      )}

      <Grid container spacing={3}>
        {/* Problem Description */}
        <Grid size={{ xs: 12 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6" color="error.main">
                  Problembeschreibung
                </Typography>
                {editingSection !== 'problem_description' && (
                  <IconButton
                    size="small"
                    onClick={() => startEditing('problem_description', thread.document_content?.problem_description || '')}
                  >
                    <EditIcon />
                  </IconButton>
                )}
              </Box>
              
              {editingSection === 'problem_description' ? (
                <Box>
                  <MarkdownEditor
                    value={sectionContent}
                    onChange={setSectionContent}
                    placeholder="Beschreiben Sie das Problem..."
                    rows={4}
                  />
                  <Box sx={{ display: 'flex', gap: 1 }}>
                    <Button
                      startIcon={<SaveIcon />}
                      onClick={() => handleUpdateSection('problem_description', sectionContent)}
                      variant="contained"
                      size="small"
                    >
                      Speichern
                    </Button>
                    <Button
                      startIcon={<CancelIcon />}
                      onClick={cancelEditing}
                      size="small"
                    >
                      Abbrechen
                    </Button>
                  </Box>
                </Box>
              ) : (
                <MarkdownRenderer content={thread.document_content?.problem_description} fallback="Noch keine Problembeschreibung vorhanden." />
              )}
            </CardContent>
          </Card>
        </Grid>

        {/* Context */}
        <Grid size={{ xs: 12 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6" color="info.main">
                  Kontext
                </Typography>
                {editingSection !== 'context' && (
                  <IconButton
                    size="small"
                    onClick={() => startEditing('context', thread.document_content?.context || '')}
                  >
                    <EditIcon />
                  </IconButton>
                )}
              </Box>
              
              {editingSection === 'context' ? (
                <Box>
                  <MarkdownEditor
                    value={sectionContent}
                    onChange={setSectionContent}
                    placeholder="Geben Sie den Kontext ein..."
                    rows={3}
                  />
                  <Box sx={{ display: 'flex', gap: 1 }}>
                    <Button
                      startIcon={<SaveIcon />}
                      onClick={() => handleUpdateSection('context', sectionContent)}
                      variant="contained"
                      size="small"
                    >
                      Speichern
                    </Button>
                    <Button
                      startIcon={<CancelIcon />}
                      onClick={cancelEditing}
                      size="small"
                    >
                      Abbrechen
                    </Button>
                  </Box>
                </Box>
              ) : (
                <MarkdownRenderer content={thread.document_content?.context} fallback="Noch kein Kontext hinzugefügt." />
              )}
            </CardContent>
          </Card>
        </Grid>

        {/* Solution Proposals */}
        <Grid size={{ xs: 12 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6" color="success.main">
                  Lösungsvorschläge
                </Typography>
                <Button
                  startIcon={<AddIcon />}
                  onClick={() => setShowProposalDialog(true)}
                  variant="outlined"
                  size="small"
                  disabled={thread.status === 'final'}
                >
                  Vorschlag hinzufügen
                </Button>
              </Box>
              
              {thread.document_content?.solution_proposals && thread.document_content.solution_proposals.length > 0 ? (
                <List>
                  {thread.document_content?.solution_proposals?.map((proposal, index) => (
                    <React.Fragment key={proposal.id}>
                      <ListItem>
                        <ListItemText
                          primary={
                            <MarkdownRenderer content={proposal.content} />
                          }
                          secondary={`Vorschlag ${index + 1} • ${new Date(proposal.created_at).toLocaleDateString('de-DE')}`}
                        />
                      </ListItem>
                      {index < (thread.document_content.solution_proposals?.length || 0) - 1 && <Divider />}
                    </React.Fragment>
                  ))}
                </List>
              ) : (
                <Typography variant="body2" color="text.secondary">
                  Noch keine Lösungsvorschläge vorhanden.
                </Typography>
              )}
            </CardContent>
          </Card>
        </Grid>

        {/* Final Solution */}
        {thread.document_content?.final_solution && (
          <Grid size={{ xs: 12 }}>
            <Card sx={{ border: '2px solid', borderColor: 'warning.main' }}>
              <CardContent>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <CheckIcon color="warning" sx={{ mr: 1 }} />
                  <Typography variant="h6" color="warning.main">
                    Finale Lösung
                  </Typography>
                </Box>
                <MarkdownRenderer content={thread.document_content?.final_solution?.content} />
                {thread.document_content?.final_solution?.approved_at && (
                  <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
                    Genehmigt am {new Date(thread.document_content?.final_solution?.approved_at || '').toLocaleDateString('de-DE')}
                  </Typography>
                )}
              </CardContent>
            </Card>
          </Grid>
        )}

        {/* Community Initiative Section */}
        {thread.status === 'final' && thread.document_content?.final_solution && (
          <Grid size={{ xs: 12 }}>
            <Card sx={{ border: '2px solid', borderColor: 'primary.main' }}>
              <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <InitiativeIcon color="primary" sx={{ mr: 1 }} />
                    <Typography variant="h6" color="primary.main">
                      Community Initiative
                    </Typography>
                  </Box>
                  
                  {!threadInitiative && (
                    <Button
                      variant="contained"
                      startIcon={<InitiativeIcon />}
                      onClick={() => setShowCreateInitiativeDialog(true)}
                      disabled={loadingInitiative}
                    >
                      Initiative starten
                    </Button>
                  )}
                </Box>

                {threadInitiative ? (
                  <InitiativeView
                    initiative={threadInitiative}
                    onUpdate={handleUpdateInitiative}
                    onStatusChange={handleInitiativeStatusChange}
                  />
                ) : (
                  <Alert severity="info" sx={{ mt: 2 }}>
                    <Typography variant="body2">
                      Basierend auf dieser finalen Lösung können Sie eine Community-Initiative starten, 
                      um diese Lösung an externe Organisationen wie BDEW, Regulierungsbehörden oder 
                      Standardisierungsgremien zu richten.
                    </Typography>
                  </Alert>
                )}
              </CardContent>
            </Card>
          </Grid>
        )}

        {/* Initiatives Section - New */}
        <Grid size={{ xs: 12 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6" color="primary.main">
                  Initiativen
                </Typography>
                <Button
                  startIcon={<InitiativeIcon />}
                  onClick={() => navigate(`/community/threads/${id}/initiatives`)}
                  variant="contained"
                  size="small"
                >
                  Alle ansehen
                </Button>
              </Box>
              
              <InitiativeView 
                threadId={id}
                initiatives={thread.document_content?.initiatives}
                onUpdate={() => fetchThread()} // Refresh on update
              />
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Add Proposal Dialog */}
      <Dialog open={showProposalDialog} onClose={() => setShowProposalDialog(false)} maxWidth="md" fullWidth>
        <DialogTitle>Neuen Lösungsvorschlag hinzufügen</DialogTitle>
        <DialogContent>
          <Box sx={{ mt: 1 }}>
            <MarkdownEditor
              value={newProposal}
              onChange={setNewProposal}
              placeholder="Beschreiben Sie Ihren Lösungsvorschlag..."
              rows={6}
            />
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowProposalDialog(false)}>
            Abbrechen
          </Button>
          <Button 
            onClick={handleAddProposal} 
            variant="contained"
            disabled={!newProposal.trim()}
          >
            Vorschlag hinzufügen
          </Button>
        </DialogActions>
      </Dialog>

      {/* Create Initiative Dialog */}
      <Dialog 
        open={showCreateInitiativeDialog} 
        onClose={() => setShowCreateInitiativeDialog(false)} 
        maxWidth="sm" 
        fullWidth
      >
        <DialogTitle>Neue Community Initiative starten</DialogTitle>
        <DialogContent>
          <Alert severity="info" sx={{ mb: 2 }}>
            Eine Initiative ermöglicht es, die finale Lösung an externe Organisationen zu richten 
            und gemeinsam strukturierte Vorschläge zu entwickeln.
          </Alert>
          
          <TextField
            fullWidth
            label="Initiative Titel"
            value={newInitiativeTitle}
            onChange={(e) => setNewInitiativeTitle(e.target.value)}
            placeholder="z.B. Verbesserung der UTILMD Validierung"
            sx={{ mb: 2 }}
          />
          
          <TextField
            fullWidth
            select
            label="Zielgruppe"
            value={newInitiativeAudience}
            onChange={(e) => setNewInitiativeAudience(e.target.value)}
            SelectProps={{ native: true }}
          >
            <option value="">Bitte wählen...</option>
            <option value="BDEW">BDEW</option>
            <option value="Regulierungsbehörde">Regulierungsbehörde</option>
            <option value="Standardisierungsgremium">Standardisierungsgremium</option>
            <option value="EDI@Energy">EDI@Energy</option>
            <option value="VDE|FNN">VDE|FNN</option>
            <option value="Bundesnetzagentur">Bundesnetzagentur</option>
            <option value="Andere">Andere</option>
          </TextField>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowCreateInitiativeDialog(false)}>
            Abbrechen
          </Button>
          <Button 
            onClick={handleCreateInitiative} 
            variant="contained"
            disabled={!newInitiativeTitle.trim() || loadingInitiative}
            startIcon={loadingInitiative ? <CircularProgress size={16} /> : <InitiativeIcon />}
          >
            Initiative erstellen
          </Button>
        </DialogActions>
      </Dialog>

      {/* Floating Action Button for Comments */}
      <Fab
        color="primary"
        aria-label="comments"
        sx={{ position: 'fixed', bottom: 16, right: 16 }}
        onClick={() => showSnackbar('Kommentar-Funktion wird bald verfügbar sein', 'info')}
      >
        <CommentIcon />
      </Fab>
    </Box>
  );
};

export default CommunityThreadDetail;
