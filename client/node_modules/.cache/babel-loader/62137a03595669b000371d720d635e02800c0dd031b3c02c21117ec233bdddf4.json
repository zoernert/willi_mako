{"ast":null,"code":"/**\n * @import {Event, Exiter, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { blankLine } from 'micromark-core-commonmark';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        name: 'gfmFootnoteDefinition',\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        name: 'gfmFootnoteCall',\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        name: 'gfmPotentialFootnoteCall',\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  };\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {Token} */\n  let labelStart;\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1];\n    if (token.type === \"labelImage\") {\n      labelStart = token;\n      break;\n    }\n\n    // Exit if weâ€™ve walked far enough.\n    if (token.type === 'gfmFootnoteCall' || token.type === \"labelLink\" || token.type === \"label\" || token.type === \"image\" || token.type === \"link\") {\n      break;\n    }\n  }\n  return start;\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code);\n    }\n    const id = normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    }));\n    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code);\n    }\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return ok(code);\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length;\n  /** @type {Token | undefined} */\n  let labelStart;\n\n  // Find an opening.\n  while (index--) {\n    if (events[index][1].type === \"labelImage\" && events[index][0] === 'enter') {\n      labelStart = events[index][1];\n      break;\n    }\n  }\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = \"data\";\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker';\n\n  // The whole (without `!`):\n  /** @type {Token} */\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  // The `^` marker\n  /** @type {Token} */\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  };\n  // Increment the end 1 character.\n  marker.end.column++;\n  marker.end.offset++;\n  marker.end._bufferIndex++;\n  /** @type {Token} */\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  };\n  /** @type {Token} */\n  const chunk = {\n    type: \"chunkString\",\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  };\n\n  /** @type {Array<Event>} */\n  const replacement = [\n  // Take the `labelImageMarker` (now `data`, the `!`)\n  events[index + 1], events[index + 2], ['enter', call, context],\n  // The `[`\n  events[index + 3], events[index + 4],\n  // The `^`.\n  ['enter', marker, context], ['exit', marker, context],\n  // Everything in between.\n  ['enter', string, context], ['enter', chunk, context], ['exit', chunk, context], ['exit', string, context],\n  // The ending (`]`, properly parsed and labelled).\n  events[events.length - 2], events[events.length - 1], ['exit', call, context]];\n  events.splice(index, events.length - index + 1, ...replacement);\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  let size = 0;\n  /** @type {boolean} */\n  let data;\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We canâ€™t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start;\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteCall');\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return callStart;\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== 94) return nok(code);\n    effects.enter('gfmFootnoteCallMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallMarker');\n    effects.enter('gfmFootnoteCallString');\n    effects.enter('chunkString').contentType = 'string';\n    return callData;\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n    // Too long.\n    size > 999 ||\n    // Closing brace with nothing.\n    code === 93 && !data ||\n    // Space or tab is not supported by GFM for some reason.\n    // `\\n` and `[` not being supported makes sense.\n    code === null || code === 91 || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n    if (code === 93) {\n      effects.exit('chunkString');\n      const token = effects.exit('gfmFootnoteCallString');\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code);\n      }\n      effects.enter('gfmFootnoteCallLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteCallLabelMarker');\n      effects.exit('gfmFootnoteCall');\n      return ok;\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n    size++;\n    effects.consume(code);\n    return code === 92 ? callEscape : callData;\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return callData;\n    }\n    return callData(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {string} */\n  let identifier;\n  let size = 0;\n  /** @type {boolean | undefined} */\n  let data;\n  return start;\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true;\n    effects.enter('gfmFootnoteDefinitionLabel');\n    effects.enter('gfmFootnoteDefinitionLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteDefinitionLabelMarker');\n    return labelAtMarker;\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionMarker');\n      effects.enter('gfmFootnoteDefinitionLabelString');\n      effects.enter('chunkString').contentType = 'string';\n      return labelInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In label.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n    // Too long.\n    size > 999 ||\n    // Closing brace with nothing.\n    code === 93 && !data ||\n    // Space or tab is not supported by GFM for some reason.\n    // `\\n` and `[` not being supported makes sense.\n    code === null || code === 91 || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n    if (code === 93) {\n      effects.exit('chunkString');\n      const token = effects.exit('gfmFootnoteDefinitionLabelString');\n      identifier = normalizeIdentifier(self.sliceSerialize(token));\n      effects.enter('gfmFootnoteDefinitionLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionLabelMarker');\n      effects.exit('gfmFootnoteDefinitionLabel');\n      return labelAfter;\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n    size++;\n    effects.consume(code);\n    return code === 92 ? labelEscape : labelInside;\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return labelInside;\n    }\n    return labelInside(code);\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker');\n      if (!defined.includes(identifier)) {\n        defined.push(identifier);\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(effects, whitespaceAfter, 'gfmFootnoteDefinitionWhitespace');\n    }\n    return nok(code);\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok));\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition');\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', 4 + 1);\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"names":["blankLine","factorySpace","markdownLineEndingOrSpace","normalizeIdentifier","indent","tokenize","tokenizeIndent","partial","gfmFootnote","document","name","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","exit","gfmFootnoteDefinitionEnd","text","tokenizeGfmFootnoteCall","add","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","effects","ok","nok","self","index","events","length","defined","parser","gfmFootnotes","labelStart","token","type","start","code","_balanced","id","sliceSerialize","end","now","codePointAt","includes","slice","enter","consume","context","call","Object","assign","marker","column","offset","_bufferIndex","string","chunk","contentType","replacement","splice","size","data","callStart","callData","callEscape","identifier","_container","labelAtMarker","labelInside","labelAfter","labelEscape","push","whitespaceAfter","check","attempt","afterPrefix","tail"],"sources":["/home/thorsten/Development/willi_mako/client/node_modules/micromark-extension-gfm-footnote/lib/syntax.js"],"sourcesContent":["/**\n * @import {Event, Exiter, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { blankLine } from 'micromark-core-commonmark';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        name: 'gfmFootnoteDefinition',\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        name: 'gfmFootnoteCall',\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        name: 'gfmPotentialFootnoteCall',\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  };\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {Token} */\n  let labelStart;\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1];\n    if (token.type === \"labelImage\") {\n      labelStart = token;\n      break;\n    }\n\n    // Exit if weâ€™ve walked far enough.\n    if (token.type === 'gfmFootnoteCall' || token.type === \"labelLink\" || token.type === \"label\" || token.type === \"image\" || token.type === \"link\") {\n      break;\n    }\n  }\n  return start;\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code);\n    }\n    const id = normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    }));\n    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code);\n    }\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return ok(code);\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length;\n  /** @type {Token | undefined} */\n  let labelStart;\n\n  // Find an opening.\n  while (index--) {\n    if (events[index][1].type === \"labelImage\" && events[index][0] === 'enter') {\n      labelStart = events[index][1];\n      break;\n    }\n  }\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = \"data\";\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker';\n\n  // The whole (without `!`):\n  /** @type {Token} */\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  // The `^` marker\n  /** @type {Token} */\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  };\n  // Increment the end 1 character.\n  marker.end.column++;\n  marker.end.offset++;\n  marker.end._bufferIndex++;\n  /** @type {Token} */\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  };\n  /** @type {Token} */\n  const chunk = {\n    type: \"chunkString\",\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  };\n\n  /** @type {Array<Event>} */\n  const replacement = [\n  // Take the `labelImageMarker` (now `data`, the `!`)\n  events[index + 1], events[index + 2], ['enter', call, context],\n  // The `[`\n  events[index + 3], events[index + 4],\n  // The `^`.\n  ['enter', marker, context], ['exit', marker, context],\n  // Everything in between.\n  ['enter', string, context], ['enter', chunk, context], ['exit', chunk, context], ['exit', string, context],\n  // The ending (`]`, properly parsed and labelled).\n  events[events.length - 2], events[events.length - 1], ['exit', call, context]];\n  events.splice(index, events.length - index + 1, ...replacement);\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  let size = 0;\n  /** @type {boolean} */\n  let data;\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We canâ€™t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start;\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteCall');\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return callStart;\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== 94) return nok(code);\n    effects.enter('gfmFootnoteCallMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallMarker');\n    effects.enter('gfmFootnoteCallString');\n    effects.enter('chunkString').contentType = 'string';\n    return callData;\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n    // Too long.\n    size > 999 ||\n    // Closing brace with nothing.\n    code === 93 && !data ||\n    // Space or tab is not supported by GFM for some reason.\n    // `\\n` and `[` not being supported makes sense.\n    code === null || code === 91 || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n    if (code === 93) {\n      effects.exit('chunkString');\n      const token = effects.exit('gfmFootnoteCallString');\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code);\n      }\n      effects.enter('gfmFootnoteCallLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteCallLabelMarker');\n      effects.exit('gfmFootnoteCall');\n      return ok;\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n    size++;\n    effects.consume(code);\n    return code === 92 ? callEscape : callData;\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return callData;\n    }\n    return callData(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {string} */\n  let identifier;\n  let size = 0;\n  /** @type {boolean | undefined} */\n  let data;\n  return start;\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true;\n    effects.enter('gfmFootnoteDefinitionLabel');\n    effects.enter('gfmFootnoteDefinitionLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteDefinitionLabelMarker');\n    return labelAtMarker;\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionMarker');\n      effects.enter('gfmFootnoteDefinitionLabelString');\n      effects.enter('chunkString').contentType = 'string';\n      return labelInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In label.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n    // Too long.\n    size > 999 ||\n    // Closing brace with nothing.\n    code === 93 && !data ||\n    // Space or tab is not supported by GFM for some reason.\n    // `\\n` and `[` not being supported makes sense.\n    code === null || code === 91 || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n    if (code === 93) {\n      effects.exit('chunkString');\n      const token = effects.exit('gfmFootnoteDefinitionLabelString');\n      identifier = normalizeIdentifier(self.sliceSerialize(token));\n      effects.enter('gfmFootnoteDefinitionLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionLabelMarker');\n      effects.exit('gfmFootnoteDefinitionLabel');\n      return labelAfter;\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n    size++;\n    effects.consume(code);\n    return code === 92 ? labelEscape : labelInside;\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return labelInside;\n    }\n    return labelInside(code);\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker');\n      if (!defined.includes(identifier)) {\n        defined.push(identifier);\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(effects, whitespaceAfter, 'gfmFootnoteDefinitionWhitespace');\n    }\n    return nok(code);\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok));\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition');\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', 4 + 1);\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok(code) : nok(code);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}