{"ast":null,"code":"/**\n * @import {Nodes, Parents, PhrasingContent, Root, Text} from 'mdast'\n * @import {BuildVisitor, Test, VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp';\nimport { visitParents } from 'unist-util-visit-parents';\nimport { convert } from 'unist-util-is';\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {};\n  const ignored = convert(settings.ignore || []);\n  const pairs = toPairs(list);\n  let pairIndex = -1;\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor);\n  }\n\n  /** @type {BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1;\n    /** @type {Parents | undefined} */\n    let grandparent;\n    while (++index < parents.length) {\n      const parent = parents[index];\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined;\n      if (ignored(parent, siblings ? siblings.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n      grandparent = parent;\n    }\n    if (grandparent) {\n      return handler(node, parents);\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1];\n    const find = pairs[pairIndex][0];\n    const replace = pairs[pairIndex][1];\n    let start = 0;\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children;\n    const index = siblings.indexOf(node);\n    let change = false;\n    /** @type {Array<PhrasingContent>} */\n    let nodes = [];\n    find.lastIndex = 0;\n    let match = find.exec(node.value);\n    while (match) {\n      const position = match.index;\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      };\n      let value = replace(...match, matchObject);\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {\n          type: 'text',\n          value\n        } : undefined;\n      }\n\n      // It wasn’t a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1;\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          });\n        }\n        if (Array.isArray(value)) {\n          nodes.push(...value);\n        } else if (value) {\n          nodes.push(value);\n        }\n        start = position + match[0].length;\n        change = true;\n      }\n      if (!find.global) {\n        break;\n      }\n      match = find.exec(node.value);\n    }\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({\n          type: 'text',\n          value: node.value.slice(start)\n        });\n      }\n      parent.children.splice(index, 1, ...nodes);\n    } else {\n      nodes = [node];\n    }\n    return index + nodes.length;\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = [];\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples');\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];\n  let index = -1;\n  while (++index < list.length) {\n    const tuple = list[index];\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);\n  }\n  return result;\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find;\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : function () {\n    return replace;\n  };\n}","map":{"version":3,"names":["escape","visitParents","convert","findAndReplace","tree","list","options","settings","ignored","ignore","pairs","toPairs","pairIndex","length","visitor","node","parents","index","grandparent","parent","siblings","children","undefined","indexOf","handler","find","replace","start","change","nodes","lastIndex","match","exec","value","position","matchObject","input","stack","type","push","slice","Array","isArray","global","splice","tupleOrList","result","TypeError","tuple","toExpression","toFunction","RegExp"],"sources":["/home/thorsten/Development/willi_mako/client/node_modules/mdast-util-find-and-replace/lib/index.js"],"sourcesContent":["/**\n * @import {Nodes, Parents, PhrasingContent, Root, Text} from 'mdast'\n * @import {BuildVisitor, Test, VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasn’t a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}